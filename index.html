<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MIDCARE© — Mid-West Acute Hospital Bed Allocation Dashboard</title>
  <style>
    :root { 
      --bg:#ffffff; 
      --panel:#f8fafc; 
      --ink:#111111; 
      --muted:#555555; 
      --accent:#0d9488;
      --border:#e5e7eb;
      --navy:#1e3a8a;
      --blue:#60a5fa;
      --teal:#0ea5a8;
    }
    *{box-sizing:border-box}
    body{ margin:0; background:var(--bg); color:var(--ink); font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif }
    header{ padding:14px; border-bottom:1px solid var(--border); background:#ffffff; }
    .title-row{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .title-logo{ height:34px; width:auto; }
    h1{ margin:0; font-size:18px; letter-spacing:.2px; color:var(--navy); line-height:1.2 }
    .wrap{ display:flex; flex-direction:column; gap:12px; padding:12px }
    .card{ background:var(--panel); border:1px solid var(--border); border-radius:12px; box-shadow:0 4px 12px rgba(0,0,0,.05) }
    .controls{padding:10px; display:grid; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); gap:10px; align-items:end}
    .group{ padding:8px; border:1px solid var(--border); border-radius:10px; background:#ffffff; }
    .group h3{ margin:0 0 6px; font-size:12px; color:var(--muted); font-weight:600; letter-spacing:.2px }
    .row{ display:flex; justify-content:space-between; align-items:center; margin:4px 0 }
    .row label{font-size:12px;color:#1f2937; flex:1}
    input[type="range"]{width:100%; height:14px; touch-action:none}
    .val{font-variant-numeric:tabular-nums;color:#334155;font-size:12px;text-align:right; min-width:40px}
    .btn{ background:var(--navy); color:#fff; border:1px solid var(--navy); padding:6px 10px; border-radius:8px; font-weight:700; cursor:pointer; font-size:12px }
    .btn:hover{ background:#172554 }
    select{ padding:4px 6px; border:1px solid var(--border); border-radius:8px; background:#fff; font-size:12px; height:28px; width:100% }
    #stage{height:440px; width:100%;}
    svg{width:100%; height:440px; display:block}
    footer{color:var(--muted);text-align:center;font-size:11px;padding:8px}
    @media (max-width: 700px){ .controls{grid-template-columns:1fr} }
  </style>
</head>
<body>
  <header>
    <div class="title-row">
      <img class="title-logo" src="https://assets.zyrosite.com/AoP61N2BR4i8Q6jl/logo-hsml-AE07eKDgMLFgWBoQ.png" alt="HSML Logo">
      <h1>MIDCARE© — Mid-West Acute Hospital Bed Allocation Dashboard (Acute Capacity Plan 2024-2031)</h1>
    </div>
  </header>
  <div class="wrap">
    <div class="card controls">
      <div class="group">
        <button class="btn" id="resetBtn">Reset to defaults</button>
      </div>

      <div class="group">
        <h3>Gap mode</h3>
        <div class="row">
          <label for="gapMode">Gap measure</label>
          <select id="gapMode">
            <option value="baseline" selected>Baseline stock</option>
            <option value="parity">Parity (allocation vs population)</option>
          </select>
        </div>
      </div>

      <div class="group">
        <h3>Reference Line</h3>
        <div class="row">
          <label for="ref">Reference (%)</label>
          <div class="val"><span id="ref-val">52.2</span>%</div>
        </div>
        <input id="ref" type="range" min="0" max="100" value="52.2" step="0.1">
      </div>

      <div class="group">
        <h3>Limerick</h3>
        <div class="row"><label>Pop. (%)</label><div class="val"><span id="pop-val-0">52.2</span>%</div></div>
        <input id="pop-0" type="range" min="0" max="100" step="0.1" value="52.2">
        <div class="row"><label>Alloc. (%)</label><div class="val"><span id="alloc-val-0">85</span>%</div></div>
        <input id="alloc-0" type="range" min="0" max="100" step="0.1" value="85">
      </div>

      <div class="group">
        <h3>Clare</h3>
        <div class="row"><label>Pop. (%)</label><div class="val"><span id="pop-val-1">31.9</span>%</div></div>
        <input id="pop-1" type="range" min="0" max="100" step="0.1" value="31.9">
        <div class="row"><label>Alloc. (%)</label><div class="val"><span id="alloc-val-1">10</span>%</div></div>
        <input id="alloc-1" type="range" min="0" max="100" step="0.1" value="10">
      </div>

      <div class="group">
        <h3>North Tipperary</h3>
        <div class="row"><label>Pop. (%)</label><div class="val"><span id="pop-val-2">15.9</span>%</div></div>
        <input id="pop-2" type="range" min="0" max="100" step="0.1" value="15.9">
        <div class="row"><label>Alloc. (%)</label><div class="val"><span id="alloc-val-2">5</span>%</div></div>
        <input id="alloc-2" type="range" min="0" max="100" step="0.1" value="5">
      </div>
    </div>

    <main class="card">
      <div id="stage">
        <svg id="chartSvg" viewBox="0 0 960 440" preserveAspectRatio="xMidYMid meet"></svg>
      </div>
    </main>
  </div>
  <footer>
    Use the sliders to adjust population and allocation. The "Gap mode" controls difference metrics:
    <b>Baseline stock</b> = planned beds. <b>Parity</b> = allocation − population, with bed equivalent.
  </footer>

  <script>
    const NAMES = ['Limerick','Clare','North Tipperary'];
    const popInputs = [ 'pop-0','pop-1','pop-2' ].map(id => document.getElementById(id));
    const allocInputs = [ 'alloc-0','alloc-1','alloc-2' ].map(id => document.getElementById(id));
    const popVals = [ 'pop-val-0','pop-val-1','pop-val-2' ].map(id => document.getElementById(id));
    const allocVals = [ 'alloc-val-0','alloc-val-1','alloc-val-2' ].map(id => document.getElementById(id));
    const gapModeSelect = document.getElementById('gapMode');

    // Ensure ALL allocation sliders are free 0–100 (attributes + runtime guards)
    allocInputs.forEach(el => { el.min = '0'; el.max = '100'; el.step='0.1'; el.addEventListener('focus',()=>{el.min='0';el.max='100'}); });

    const defaults = {
      ref: 52.2,
      pops: [52.2, 31.9, 15.9],
      allocs: [85, 10, 5],
      gapMode: 'baseline'
    };

    const baseline = {
      'Limerick':        { pct: 85, beds: 310, parts: [184,84,42] },
      'Clare':           { pct: 10, beds: 48 },
      'North Tipperary': { pct:  5, beds: 24 }
    };

    const svg = document.getElementById('chartSvg');
    const PAD = {l:64,r:24,t:28,b:52};
    const W = 960, H = 440;

    function clearSVG(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

    function drawAxes(maxY){
      for(let y=0;y<=maxY;y+=10){
        const yy = H-PAD.b - (y/maxY)*(H-PAD.t-PAD.b);
        const grid = document.createElementNS('http://www.w3.org/2000/svg','line');
        grid.setAttribute('x1', PAD.l); grid.setAttribute('x2', W-PAD.r);
        grid.setAttribute('y1', yy); grid.setAttribute('y2', yy);
        grid.setAttribute('stroke', '#e5e7eb'); grid.setAttribute('stroke-width','1');
        grid.setAttribute('opacity', y%20===0 ? 1:0.45);
        svg.appendChild(grid);

        const label = document.createElementNS('http://www.w3.org/2000/svg','text');
        label.setAttribute('x', PAD.l-8); label.setAttribute('y', yy+3);
        label.setAttribute('text-anchor','end'); label.setAttribute('fill','#111111');
        label.setAttribute('font-size','11');
        label.textContent = y;
        svg.appendChild(label);
      }
      const midY = PAD.t + (H - PAD.t - PAD.b) / 2;
      const yTitle = document.createElementNS('http://www.w3.org/2000/svg','text');
      yTitle.setAttribute('x', 20);
      yTitle.setAttribute('y', midY);
      yTitle.setAttribute('fill', '#555555');
      yTitle.setAttribute('font-size', '11');
      yTitle.setAttribute('text-anchor', 'middle');
      yTitle.setAttribute('transform', `rotate(-90 20 ${midY})`);
      yTitle.textContent = 'Percentage';
      svg.appendChild(yTitle);
    }

    function scaleBeds(name, pct){
      const base = baseline[name];
      if(!base) return { total: 0, parts: [] };
      if (Math.abs(pct - base.pct) < 1e-9) {
        return { total: base.beds, parts: base.parts ? base.parts.slice() : [] };
      }
      const factor = pct / base.pct;
      const total = Math.round(base.beds * factor);
      if(base.parts){
        let parts = base.parts.map(v => Math.round(v * factor));
        let diff = total - parts.reduce((a,b)=>a+b,0);
        if(diff !== 0){
          const idx = parts.indexOf(Math.max(...parts));
          parts[idx] += diff;
        }
        return { total, parts };
      }
      return { total, parts: [] };
    }

    function draw(){
      clearSVG();
      const pop = popInputs.map(el => parseFloat(el.value));
      const alloc = allocInputs.map(el => parseFloat(el.value));
      const maxY = Math.max(100, ...pop, ...alloc);
      drawAxes(maxY);

      const ref = parseFloat(document.getElementById('ref').value);
      document.getElementById('ref-val').textContent = ref.toFixed(1);
      const yRef = H-PAD.b - (ref/maxY)*(H-PAD.t-PAD.b);
      const refLine = document.createElementNS('http://www.w3.org/2000/svg','line');
      refLine.setAttribute('x1', PAD.l-8); refLine.setAttribute('x2', W-PAD.r);
      refLine.setAttribute('y1', yRef); refLine.setAttribute('y2', yRef);
      refLine.setAttribute('stroke', '#0d9488'); refLine.setAttribute('stroke-dasharray','6,6'); refLine.setAttribute('stroke-width','2');
      svg.appendChild(refLine);

      const title = document.createElementNS('http://www.w3.org/2000/svg','text');
      title.setAttribute('x', (W/2)); title.setAttribute('y', 22);
      title.setAttribute('text-anchor','middle'); title.setAttribute('fill','#111111');
      title.setAttribute('font-size','14'); title.textContent = 'Resource Allocation vs. Population Proportion';
      svg.appendChild(title);

      const mode = gapModeSelect.value;
      const legendItems = [
        ['#0ea5a8','Resource Allocation (%)'],
        ['#60a5fa','Population Proportion (%)'],
        ...(mode==='parity' ? [['#16a34a','Surplus vs parity (+)'], ['#dc2626','Shortfall vs parity (–)']] : [['#16a34a','Surplus vs baseline (+)'], ['#dc2626','Shortfall vs baseline (–)']])
      ];
      const legendY = PAD.t + 12;
      const startX = W - PAD.r - 480;
      legendItems.forEach((d, j)=>{
        const gX = startX + (j%2)*240;
        const gY = legendY + Math.floor(j/2)*18;
        const box = document.createElementNS('http://www.w3.org/2000/svg','rect');
        box.setAttribute('x', gX); box.setAttribute('y', gY-10);
        box.setAttribute('width', 12); box.setAttribute('height', 12); box.setAttribute('fill', d[0]); svg.appendChild(box);
        const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
        txt.setAttribute('x', gX+18); txt.setAttribute('y', gY);
        txt.setAttribute('fill','#111111'); txt.setAttribute('font-size','11'); txt.textContent = d[1]; svg.appendChild(txt);
      });

      const groups = NAMES.length; const band = (W-PAD.l-PAD.r)/groups; const gap = 14;
      const barW = (band - gap)/2;

      NAMES.forEach((name, i) => {
        const x0 = PAD.l + i*band;
        const hA = (alloc[i]/maxY)*(H-PAD.t-PAD.b);
        const yA = H-PAD.b - hA;
        const rectA = document.createElementNS('http://www.w3.org/2000/svg','rect');
        rectA.setAttribute('x', x0 + gap/2);
        rectA.setAttribute('y', yA);
        rectA.setAttribute('width', barW);
        rectA.setAttribute('height', hA);
        rectA.setAttribute('fill', '#0ea5a8');
        svg.appendChild(rectA);

        const hP = (pop[i]/maxY)*(H-PAD.t-PAD.b);
        const yP = H-PAD.b - hP;
        const rectP = document.createElementNS('http://www.w3.org/2000/svg','rect');
        rectP.setAttribute('x', x0 + gap/2 + barW + 5);
        rectP.setAttribute('y', yP);
        rectP.setAttribute('width', barW);
        rectP.setAttribute('height', hP);
        rectP.setAttribute('fill', '#60a5fa');
        svg.appendChild(rectP);

        const xl = document.createElementNS('http://www.w3.org/2000/svg','text');
        xl.setAttribute('x', x0 + band/2); xl.setAttribute('y', H-26);
        xl.setAttribute('text-anchor','middle'); xl.setAttribute('fill','#111111'); xl.setAttribute('font-size','11');
        xl.textContent = name; svg.appendChild(xl);

        const plannedBeds = scaleBeds(name, alloc[i]);
        const annA = document.createElementNS('http://www.w3.org/2000/svg','text');
        annA.setAttribute('x', x0 + gap/2 + barW/2);
        annA.setAttribute('y', yA-5);
        annA.setAttribute('text-anchor','middle');
        annA.setAttribute('fill','#111111');
        annA.setAttribute('font-size','10');
        if(plannedBeds.parts.length){
          annA.textContent = Math.round(alloc[i]) + '% (' + plannedBeds.parts.join('+') + '=' + plannedBeds.total + ' beds)';
        } else {
          annA.textContent = Math.round(alloc[i]) + '% (' + plannedBeds.total + ' beds)';
        }
        svg.appendChild(annA);

        const annP = document.createElementNS('http://www.w3.org/2000/svg','text');
        annP.setAttribute('x', x0 + gap/2 + barW + 5 + barW/2);
        annP.setAttribute('y', yP-5);
        annP.setAttribute('text-anchor','middle');
        annP.setAttribute('fill','#1f2937');
        annP.setAttribute('font-size','10');
        annP.textContent = pop[i].toFixed(1) + '%';
        svg.appendChild(annP);

        const colorize = (val) => (val < 0 ? '#dc2626' : (val > 0 ? '#16a34a' : '#6b7280'));

        if (mode === 'parity') {
          const midLeft  = x0 + gap/2 + barW/2;
          const midRight = x0 + gap/2 + barW + 5 + barW/2;
          const yBracket = Math.min(yA, yP) - 12;
          const gapPct = alloc[i] - pop[i];
          const parityBeds = scaleBeds(name, pop[i]);
          const bedDiff = parityBeds.total - plannedBeds.total;

          const color = colorize(gapPct);
          ['L','R'].forEach(side=>{
            const tick = document.createElementNS('http://www.w3.org/2000/svg','line');
            const x = side==='L' ? midLeft : midRight;
            tick.setAttribute('x1', x); tick.setAttribute('x2', x);
            tick.setAttribute('y1', yBracket); tick.setAttribute('y2', yBracket+7);
            tick.setAttribute('stroke', color); tick.setAttribute('stroke-width','2');
            svg.appendChild(tick);
          });
          const conn = document.createElementNS('http://www.w3.org/2000/svg','line');
          conn.setAttribute('x1', midLeft); conn.setAttribute('x2', midRight);
          conn.setAttribute('y1', yBracket); conn.setAttribute('y2', yBracket);
          conn.setAttribute('stroke', color); conn.setAttribute('stroke-width','2');
          svg.appendChild(conn);

          const label = document.createElementNS('http://www.w3.org/2000/svg','text');
          label.setAttribute('x', (midLeft+midRight)/2); label.setAttribute('y', yBracket-4);
          label.setAttribute('text-anchor','middle'); label.setAttribute('fill', color); label.setAttribute('font-size','10');
          const pctTxt = (gapPct===0)? 'Parity' : (gapPct < 0 ? `Shortfall ${Math.abs(gapPct).toFixed(1)}%` : `Surplus +${gapPct.toFixed(1)}%`);
          const bedTxt = (gapPct===0)? '' : ` (≈ ${Math.abs(bedDiff)} beds)`;
          label.textContent = pctTxt + bedTxt;
          svg.appendChild(label);
        } else {
          const baseBeds = baseline[name].beds;
          const bedDiffBase = plannedBeds.total - baseBeds;
          const color = colorize(bedDiffBase);
          const label = document.createElementNS('http://www.w3.org/2000/svg','text');
          label.setAttribute('x', x0 + gap/2 + barW/2);
          label.setAttribute('y', yA - 18);
          label.setAttribute('text-anchor','middle'); label.setAttribute('fill', color); label.setAttribute('font-size','10');
          if (bedDiffBase === 0) {
            label.textContent = `= ${baseBeds} beds (current)`;
          } else if (bedDiffBase > 0) {
            label.textContent = `+${bedDiffBase} beds vs current (${baseBeds})`;
          } else {
            label.textContent = `${bedDiffBase} beds vs current (${baseBeds})`;
          }
          svg.appendChild(label);
        }
      });
    }

    const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
    function getPops(){ return popInputs.map(el => parseFloat(el.value)); }

    // Redistribution with PARITY = pro‑rata to population for the *other two*
    function redistribute(indexChanged, newVal){
      const cur = allocInputs.map(el => parseFloat(el.value));
      const mode = gapModeSelect.value;
      const ps = getPops();

      // Always honor full 0–100 for the changed slider
      cur[indexChanged] = clamp(newVal, 0, 100);

      if (mode === 'parity'){
        const others = [0,1,2].filter(i => i !== indexChanged);
        const remaining = clamp(100 - cur[indexChanged], 0, 100);
        const sumPopOthers = ps[others[0]] + ps[others[1]];
        if (sumPopOthers > 0){
          cur[others[0]] = remaining * (ps[others[0]] / sumPopOthers);
          cur[others[1]] = remaining * (ps[others[1]] / sumPopOthers);
        } else { cur[others[0]] = remaining/2; cur[others[1]] = remaining/2; }
      } else {
        // Baseline: take/give from the others to keep total 100
        const others = [0,1,2].filter(i => i !== indexChanged);
        let rest = 100 - cur[indexChanged];
        // Split remaining across others preserving their ratio to previous sum
        const prevSum = allocInputs[others[0]].valueAsNumber + allocInputs[others[1]].valueAsNumber;
        if (prevSum > 0){
          cur[others[0]] = rest * (allocInputs[others[0]].valueAsNumber / prevSum);
          cur[others[1]] = rest * (allocInputs[others[1]].valueAsNumber / prevSum);
        } else { cur[others[0]] = rest/2; cur[others[1]] = rest/2; }
      }

      // Write back (and fix rounding diff)
      const total = cur[0] + cur[1] + cur[2];
      const diff = 100 - total;
      if (Math.abs(diff) > 1e-6){
        const idx = cur.indexOf(Math.max(...cur));
        cur[idx] = clamp(cur[idx] + diff, 0, 100);
      }
      for (let i=0;i<3;i++){
        allocInputs[i].value = cur[i];
        allocVals[i].textContent = Math.round(cur[i]);
      }
    }

    document.getElementById('ref').addEventListener('input', () => { 
      const v = parseFloat(document.getElementById('ref').value);
      document.getElementById('ref-val').textContent = v.toFixed(1);
      draw(); 
    });

    popInputs.forEach((el, i) => el.addEventListener('input', () => { 
      popVals[i].textContent = parseFloat(el.value).toFixed(1); 
      draw(); 
    }));

    [0,1,2].forEach(i => {
      allocInputs[i].addEventListener('input', () => {
        const newVal = allocInputs[i].valueAsNumber;
        redistribute(i, newVal);
        draw();
      });
    });

    gapModeSelect.addEventListener('change', draw);

    document.getElementById('resetBtn').addEventListener('click', () => {
      document.getElementById('ref').value = defaults.ref;
      document.getElementById('ref-val').textContent = defaults.ref.toFixed(1);
      gapModeSelect.value = defaults.gapMode;
      ['pop','alloc'].forEach(kind=>{
        [0,1,2].forEach(i=>{
          document.getElementById(kind+'-'+i).value = defaults[kind+'s'][i];
          document.getElementById(kind+'-val-'+i).textContent = (kind==='pop' ? defaults.pops[i].toFixed(1) : Math.round(defaults.allocs[i]));
        });
      });
      draw();
    });

    draw();
  </script>
</body>
</html>







